# NativeMessageBox.CrossPlatformSample

This solution demonstrates invoking the native message box from a single Avalonia UI project that targets desktop, iOS, Android, and WebAssembly.

## Projects

- `NativeMessageBox.CrossPlatformSample` — shared Avalonia UI, view models, and XAML.
- `NativeMessageBox.CrossPlatformSample.Desktop` — desktop entry point (macOS/Linux/Windows).
- `NativeMessageBox.CrossPlatformSample.iOS` — iOS entry point; consumes `NativeMessageBox.xcframework` when available.
- `NativeMessageBox.CrossPlatformSample.Android` — Android entry point; consumes `NativeMessageBox.aar` when available.
- `NativeMessageBox.CrossPlatformSample.Browser` — WebAssembly head (renders the JavaScript overlay host shipped with `NativeMessageBox` and optionally loads the compiled `libnativemessagebox.wasm` artifacts when available).

The shared project references the managed `NativeMessageBox` library. Each mobile head wires platform-specific lifecycle hooks to supply native handles (e.g., the Android tracker provides the foreground `Activity`).

## Prerequisites

- .NET 8 SDK (`8.0.x`).
- For iOS: Xcode + command-line tools.
- For Android: Android SDK/NDK (matching the versions used by the packaging scripts). Ensure `ANDROID_SDK_ROOT` and `ANDROID_NDK_ROOT` are set when building locally.

## Build Instructions

### Desktop

```bash
dotnet run --project NativeMessageBox.CrossPlatformSample.Desktop
```

### iOS (Simulator)

1. Produce the XCFramework (if not already generated by CI):
   ```bash
   ./build/scripts/package-ios-xcframework.sh
   ```
2. Build the iOS head:
   ```bash
   dotnet build NativeMessageBox.CrossPlatformSample.iOS -c Debug -f net8.0-ios
   ```
3. Deploy to a simulator with:
   ```bash
   dotnet publish NativeMessageBox.CrossPlatformSample.iOS -c Debug -f net8.0-ios /p:RunSimulator=true
   ```

### Android

1. Package the Android AAR (runs automatically in CI):
   ```bash
   ./build/scripts/package-android-aar.sh
   ```
   This drops `NativeMessageBox.aar` and per-ABI `.so` files into `artifacts/android/`.

2. Build and deploy:
   ```bash
   dotnet build NativeMessageBox.CrossPlatformSample.Android -c Debug -f net8.0-android
   dotnet publish NativeMessageBox.CrossPlatformSample.Android -c Debug -f net8.0-android /p:AndroidSdkDirectory=$ANDROID_SDK_ROOT /p:AndroidNdkDirectory=$ANDROID_NDK_ROOT
   ```
   Use `dotnet android install` or your preferred device manager to sideload the resulting APK.

The Android head registers `NativeMessageBoxActivityTracker`, which keeps a global reference to the foreground activity and feeds it to `NativeMessageBoxClient`.

### Browser (WASM)

1. (Optional) Package the WebAssembly artifacts:
   ```bash
   ./build/scripts/package-wasm.sh
   ```
   When this folder exists, the browser head automatically copies
   `libnativemessagebox.wasm` (and its companion `libnativemessagebox.js/.map`)
   into `wwwroot/native/`.

2. Launch the browser head:
   ```bash
   dotnet run --project NativeMessageBox.CrossPlatformSample.Browser
   ```

The browser target always registers the JavaScript host from
`message_box.js`, which renders accessible overlay dialogs. If the packaged
`libnativemessagebox.wasm` artifacts are present they are served alongside the
application for experimentation, but the managed host does not depend on them.

## Notes

- If `NativeMessageBox.xcframework` or `NativeMessageBox.aar` are absent, the projects fall back to compiling the platform bridge sources directly (helpful during development).
- CI produces fresh mobile artifacts and Robolectric tests exercise `NativeMessageBoxBridge.setTestCallback` to ensure JNI callbacks stay responsive.
